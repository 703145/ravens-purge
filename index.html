<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forbidden Lands RPG Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #map {
            width: 100%;
            height: 100vh;
        }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .brush-size {
            width: 100px;
            margin: 5px 0;
        }
        .button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .button:hover {
            background: #e0e0e0;
        }
        .button.active {
            background: #007bff;
            color: white;
        }
        #cursor {
            position: absolute;
            border: 2px solid red;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        #map.drawing-mode {
            cursor: crosshair !important;
        }
        .status-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div>
            <button id="gm-toggle" class="button">GM Mode: OFF</button>
        </div>
        <div>
            <button id="reveal-toggle" class="button">Reveal Mode</button>
            <button id="erase-toggle" class="button">Erase Mode</button>
        </div>
        <div>
            <label>Brush Size: <span id="brush-size-display">20</span></label>
            <input type="range" id="brush-size" class="brush-size" min="10" max="100" value="20">
        </div>
        <div>
            <button id="save-map" class="button">Save Map</button>
            <button id="clear-map" class="button">Clear All</button>
        </div>
    </div>

    <div id="status" class="status-indicator">Drawing Mode - Press ESC to exit</div>
    <div id="cursor"></div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        const mapWidth = 8563;
        const mapHeight = 6201;
        const mapBounds = [[0, 0], [mapHeight, mapWidth]];

        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: -2,
            maxZoom: 2,
            zoomControl: true,
            maxBounds: mapBounds,
            maxBoundsViscosity: 1.0
        });

        const mapImage = L.imageOverlay('assets/ravenland-map.jpg', mapBounds).addTo(map);
        map.fitBounds(mapBounds);
        map.setView([mapHeight / 2, mapWidth / 2], 0);

        // Canvas setup with memory optimization
        const canvas = document.createElement('canvas');
        canvas.width = mapWidth;
        canvas.height = mapHeight;
        const ctx = canvas.getContext('2d', { 
            willReadFrequently: true,
            alpha: false
        });

        const canvasLayer = L.imageOverlay(canvas, mapBounds).addTo(map);

        // UI elements
        const elements = {
            gmToggle: document.getElementById('gm-toggle'),
            revealToggle: document.getElementById('reveal-toggle'),
            eraseToggle: document.getElementById('erase-toggle'),
            brushSize: document.getElementById('brush-size'),
            brushSizeDisplay: document.getElementById('brush-size-display'),
            cursor: document.getElementById('cursor'),
            saveMapBtn: document.getElementById('save-map'),
            clearMapBtn: document.getElementById('clear-map'),
            status: document.getElementById('status'),
            map: document.getElementById('map')
        };

        // State
        const state = {
            isGMMode: false,
            isDrawing: false,
            isDrawingMode: false,
            currentTool: 'reveal',
            lastPoint: null,
            lastDrawTime: 0
        };

        // Initialize fog
        function initializeFog() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, mapWidth, mapHeight);
            updateCanvasLayer();
        }
        initializeFog();

        // Load saved state
        const savedMap = localStorage.getItem('rpgMapState');
        if (savedMap) {
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                updateCanvasLayer();
            };
            img.src = savedMap;
        }

        // Drawing mode functions
        function enableDrawingMode() {
            state.isDrawingMode = true;
            elements.map.classList.add('drawing-mode');
            elements.status.style.display = 'block';
            map.dragging.disable();
            map.boxZoom.disable();
            map.touchZoom.disable();
            map.doubleClickZoom.disable();
            map.scrollWheelZoom.disable();
        }

        function disableDrawingMode() {
            state.isDrawingMode = false;
            elements.map.classList.remove('drawing-mode');
            elements.status.style.display = 'none';
            map.dragging.enable();
            map.boxZoom.enable();
            map.touchZoom.enable();
            map.doubleClickZoom.enable();
            map.scrollWheelZoom.enable();
            state.isDrawing = false;
            
            // Remove active state from tool buttons
            elements.revealToggle.classList.remove('active');
            elements.eraseToggle.classList.remove('active');
        }

        // Improved brush size calculations
        function getScaledBrushSize() {
            const zoom = map.getZoom();
            const baseSize = parseInt(elements.brushSize.value);
            return baseSize / Math.pow(2, zoom + 1);
        }

        function updateBrushSize() {
            const size = elements.brushSize.value;
            elements.brushSizeDisplay.textContent = size;
            const screenSize = size * map.getZoomScale(map.getZoom());
            elements.cursor.style.width = screenSize + 'px';
            elements.cursor.style.height = screenSize + 'px';
        }

        function updateCursor(e) {
            const size = parseInt(elements.brushSize.value) * map.getZoomScale(map.getZoom());
            elements.cursor.style.left = (e.clientX - size/2) + 'px';
            elements.cursor.style.top = (e.clientY - size/2) + 'px';
        }

        // Fixed drawing function
        function drawPoint(point) {
            // Convert lat/lng to pixel coordinates directly using map methods
            const layerPoint = map.latLngToContainerPoint(point);
            const { x: canvasX, y: canvasY } = map.latLngToLayerPoint(point);
            const scaledSize = getScaledBrushSize();

            if (state.lastPoint) {
                const lastLayerPoint = map.latLngToLayerPoint(state.lastPoint);
                
                // Interpolate points for smooth lines
                const distance = Math.sqrt(Math.pow(canvasX - lastLayerPoint.x, 2) + Math.pow(canvasY - lastLayerPoint.y, 2));
                const steps = Math.ceil(distance / (scaledSize / 4));
                
                for (let i = 0; i <= steps; i++) {
                    const px = lastLayerPoint.x + (canvasX - lastLayerPoint.x) * (i / steps);
                    const py = lastLayerPoint.y + (canvasY - lastLayerPoint.y) * (i / steps);
                    
                    ctx.beginPath();
                    ctx.arc(px, py, scaledSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, scaledSize, 0, Math.PI * 2);
                ctx.fill();
            }

            state.lastPoint = point;
        }

        function draw(e) {
            if (!state.isGMMode || !state.isDrawingMode) return;

            const now = performance.now();
            if (now - state.lastDrawTime < 16) return; // 60fps throttle
            state.lastDrawTime = now;

            const point = map.mouseEventToLatLng(e);

            ctx.globalCompositeOperation = state.currentTool === 'reveal' ? 'destination-out' : 'source-over';
            ctx.fillStyle = 'black';

            drawPoint(point);
            requestAnimationFrame(updateCanvasLayer);
        }

        function updateCanvasLayer() {
            canvasLayer.setUrl(canvas.toDataURL());
        }

        // Event listeners
        map.on('mousemove', (e) => {
            if (state.isGMMode) {
                updateCursor(e.originalEvent);
                if (state.isDrawing) {
                    draw(e.originalEvent);
                }
            }
        });

        map.on('mousedown', (e) => {
            if (state.isDrawingMode) {
                state.isDrawing = true;
                state.lastPoint = null;
                draw(e.originalEvent);
            }
        });

        map.on('mouseup', () => {
            state.isDrawing = false;
            state.lastPoint = null;
        });

        map.on('mouseout', () => {
            state.isDrawing = false;
            state.lastPoint = null;
            elements.cursor.style.display = 'none';
        });

        map.on('mouseover', () => {
            if (state.isGMMode) elements.cursor.style.display = 'block';
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                disableDrawingMode();
            }
        });

        // UI event listeners with updated toggle behavior
        elements.gmToggle.addEventListener('click', () => {
            state.isGMMode = !state.isGMMode;
            elements.gmToggle.textContent = 'GM Mode: ' + (state.isGMMode ? 'ON' : 'OFF');
            elements.gmToggle.classList.toggle('active');
            elements.cursor.style.display = state.isGMMode ? 'block' : 'none';
            if (!state.isGMMode) {
                disableDrawingMode();
            }
        });

        elements.revealToggle.addEventListener('click', () => {
            if (state.currentTool === 'reveal' && state.isDrawingMode) {
                // If already in reveal mode and drawing, disable drawing
                disableDrawingMode();
            } else {
                // Enable reveal mode and drawing
                state.currentTool = 'reveal';
                elements.revealToggle.classList.add('active');
                elements.eraseToggle.classList.remove('active');
                enableDrawingMode();
            }
        });

        elements.eraseToggle.addEventListener('click', () => {
            if (state.currentTool === 'erase' && state.isDrawingMode) {
                // If already in erase mode and drawing, disable drawing
                disableDrawingMode();
            } else {
                // Enable erase mode and drawing
                state.currentTool = 'erase';
                elements.eraseToggle.classList.add('active');
                elements.revealToggle.classList.remove('active');
                enableDrawingMode();
            }
        });

        elements.brushSize.addEventListener('input', updateBrushSize);

        elements.saveMapBtn.addEventListener('click', () => {
            try {
                localStorage.setItem('rpgMapState', canvas.toDataURL());
                alert('Map state saved successfully!');
            } catch (e) {
                alert('Failed to save map state. The revealed area might be too large for local storage.');
            }
        });

        elements.clearMapBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all revealed areas?')) {
                initializeFog();
                localStorage.removeItem('rpgMapState');
            }
        });

        // Initial setup
        updateBrushSize();
    </script>
</body>
</html>