<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forbidden Lands v0.18</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #map {
            width: 100%;
            height: 100vh;
        }
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .button:hover {
            background: #e0e0e0;
        }
        .button.active {
            background: #007bff;
            color: white;
        }
        #cursor {
            position: absolute;
            border: 2px solid red;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <button id="gm-toggle" class="button">GM Mode: OFF</button>
        <button id="reveal-toggle" class="button">Reveal Mode</button>
        <button id="erase-toggle" class="button">Erase Mode</button>
        <label>Brush Size: <span id="brush-size-display">20</span></label>
        <input type="range" id="brush-size" min="10" max="100" value="20">
        <button id="save-map" class="button">Save Map</button>
        <button id="clear-map" class="button">Clear All</button>
    </div>
    <div id="cursor"></div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        // Map setup
        const mapWidth = 8563, mapHeight = 6201;
        const mapBounds = [[0, 0], [mapHeight, mapWidth]];

        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: -2,
            maxZoom: 2,
            zoomControl: true,
            maxBounds: mapBounds,
            maxBoundsViscosity: 1.0
        });

        L.imageOverlay('assets/ravenland-map.jpg', mapBounds).addTo(map);
        map.fitBounds(mapBounds);

        // Offscreen canvas for fog
        const canvas = document.createElement('canvas');
        canvas.width = mapWidth;
        canvas.height = mapHeight;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const canvasLayer = L.imageOverlay(canvas, mapBounds).addTo(map);

        // UI elements
        const gmToggle = document.getElementById('gm-toggle');
        const revealToggle = document.getElementById('reveal-toggle');
        const eraseToggle = document.getElementById('erase-toggle');
        const brushSize = document.getElementById('brush-size');
        const brushSizeDisplay = document.getElementById('brush-size-display');
        const cursor = document.getElementById('cursor');
        const saveMapBtn = document.getElementById('save-map');
        const clearMapBtn = document.getElementById('clear-map');

        // State
        let isGMMode = false, isDrawing = false, currentTool = 'reveal';

        // Initialize fog
        function initializeFog() {
            ctx.fillStyle = 'black';
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillRect(0, 0, mapWidth, mapHeight);
            updateCanvasLayer();
        }
        initializeFog();

        // Load saved map state
        function loadSavedState() {
            const savedMap = localStorage.getItem('rpgMapState');
            if (savedMap) {
                const img = new Image();
                img.onload = function () {
                    ctx.drawImage(img, 0, 0);
                    updateCanvasLayer();
                };
                img.src = savedMap;
            }
        }
        loadSavedState();

        // Brush size calculations
        function getScaledBrushSize() {
            const zoom = map.getZoom();
            const baseSize = parseInt(brushSize.value);
            return baseSize / map.getZoomScale(zoom); // Corrects for zoom level
        }

        function updateBrushSize() {
            brushSizeDisplay.textContent = brushSize.value;
            const size = parseInt(brushSize.value) * map.getZoomScale(map.getZoom());
            cursor.style.width = size + 'px';
            cursor.style.height = size + 'px';
        }

        function updateCursor(e) {
            const size = parseInt(brushSize.value) * map.getZoomScale(map.getZoom());
            cursor.style.left = (e.clientX - size / 2) + 'px';
            cursor.style.top = (e.clientY - size / 2) + 'px';
        }

        function draw(e) {
            if (!isGMMode) return;

            const point = map.mouseEventToLatLng(e);
            const x = (point.lng / mapWidth) * canvas.width;
            const y = canvas.height - (point.lat / mapHeight) * canvas.height;

            const scaledSize = getScaledBrushSize() * canvas.width / map.getContainer().clientWidth;

            ctx.beginPath();
            ctx.arc(x, y, scaledSize, 0, Math.PI * 2);
            ctx.globalCompositeOperation = currentTool === 'reveal' ? 'destination-out' : 'source-over';
            ctx.fillStyle = 'black';
            ctx.fill();

            requestAnimationFrame(updateCanvasLayer);
        }

        function updateCanvasLayer() {
            canvasLayer.setUrl(canvas.toDataURL());
        }

        let drawRequest;
        map.on('mousemove', (e) => {
            if (isGMMode) {
                updateCursor(e.originalEvent);
                if (isDrawing) {
                    cancelAnimationFrame(drawRequest);
                    drawRequest = requestAnimationFrame(() => draw(e.originalEvent));
                }
            }
        });

        map.on('mousedown', (e) => { isDrawing = true; draw(e.originalEvent); });
        map.on('mouseup', () => { isDrawing = false; });

        gmToggle.addEventListener('click', () => {
            isGMMode = !isGMMode;
            gmToggle.textContent = 'GM Mode: ' + (isGMMode ? 'ON' : 'OFF');
            gmToggle.classList.toggle('active');
            cursor.style.display = isGMMode ? 'block' : 'none';
        });

        revealToggle.addEventListener('click', () => {
            currentTool = 'reveal';
            revealToggle.classList.add('active');
            eraseToggle.classList.remove('active');
        });

        eraseToggle.addEventListener('click', () => {
            currentTool = 'erase';
            eraseToggle.classList.add('active');
            revealToggle.classList.remove('active');
        });

        brushSize.addEventListener('input', updateBrushSize);

        saveMapBtn.addEventListener('click', () => {
            localStorage.setItem('rpgMapState', canvas.toDataURL());
            alert('Map saved!');
        });

        clearMapBtn.addEventListener('click', () => {
            if (confirm('Clear all revealed areas?')) {
                initializeFog();
                localStorage.removeItem('rpgMapState');
            }
        });

        updateBrushSize();
    </script>
</body>
</html>
